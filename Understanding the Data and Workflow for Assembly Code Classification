**1. Introduction**

The goal of this report is to provide an overview of the dataset and the workflow for classifying assembly code into benign and malware categories using machine learning techniques. This involves preprocessing the assembly code data, training models, and evaluating their performance.

**2. Dataset Structure**

The dataset is structured as follows:

- **disassembled/**: Root directory containing all data related to disassembled assembly code.
    - **train_benign/**: Directory containing benign assembly code files used for training.
    - **train_malware/**: Directory containing malware assembly code files used for training.
    - **data_Set/**: Directory that may contain additional data related to the dataset.

**3. Workflow Overview**

The workflow involves several key scripts:

- **`preprocess_assembly.py`**: This script preprocesses assembly code files by removing comments, standardizing formatting, and preparing labels. It outputs clean and standardized assembly code files.
- **`load_and_preprocess_data.py`**: This script loads the preprocessed assembly code data, tokenizes it using TensorFlow's Keras API, pads sequences to ensure uniform input size, and prepares the data for training. It saves the preprocessed data and tokenizer for future use.
- **t`rain_model.py`**: This script defines and trains two types of models (CNN and RNN) using TensorFlow/Keras. These models are trained on the preprocessed assembly code data to classify between benign and malware categories.
- **`evaluate_model.py`**: This script evaluates the trained models' performance on a test set, providing metrics such as accuracy, precision, recall, and F1-score to assess their effectiveness in classifying assembly code.

**4. Detailed Workflow Steps**

**Preprocessing (preprocess_assembly.py):**

- Reads assembly code files from **train_benign/** and **train_malware/** directories.
- Removes comments, unnecessary whitespace, and standardizes formatting.
- Standardizes labels to ensure consistency across files.

**Loading and Preprocessing Data (load_and_preprocess_data.py):**

- Loads preprocessed assembly code data from **train_benign/** and **train_malware/** directories.
- Uses `Tokenizer` from TensorFlow's Keras API to tokenize the text data and build a vocabulary.
- Converts text data to sequences of integers and pads sequences to a maximum length to ensure uniform input size.
- Splits the data into training and testing sets using `train_test_split` from `sklearn.model_selection`.
- Saves the preprocessed data (`X_train.npy`, `X_test.npy`, `y_train.npy`, `y_test.npy`) and tokenizer (`tokenizer.pickle`) for later use.

**Model Training (train_model.py):**

- Loads the preprocessed data (`X_train.npy`, `X_test.npy`, `y_train.npy`, `y_test.npy`) and tokenizer (`tokenizer.pickle`).
- Defines two types of models:
    - **CNN Model**: Utilizes convolutional layers for feature extraction from sequences.
    - **RNN Model**: Utilizes recurrent layers (LSTM) for learning sequential patterns.
- Compiles and trains both models using the preprocessed assembly code data.
- Saves the trained models (`cnn_model.h5` and `rnn_model.h5`) after training.

**Model Evaluation (evaluate_model.py):**

- Loads the trained models (`cnn_model.h5` and `rnn_model.h5`).
- Loads the test set data (`X_test.npy`, `y_test.npy`) and tokenizer (`tokenizer.pickle`).
- Evaluates the performance of both models on the test set using metrics such as accuracy.
- Outputs metrics to assess the classification performance of the models.

**5. Conclusion**

This report has provided an overview of the dataset structure and the workflow for classifying assembly code into benign and malware categories using machine learning models. The process includes preprocessing assembly code data, training CNN and RNN models, and evaluating their performance. The scripts `preprocess_assembly.py`, `load_and_preprocess_data.py`, `train_model.py`, and `evaluate_model.py` collectively enable this workflow, ensuring effective classification of assembly code based on its structure and content.

This structured approach allows for the automation of classification tasks, aiding in the identification of potential malware based on assembly code characteristics. Future work may involve optimizing model performance, exploring different architectures, and integrating additional features for enhanced classification accuracy.

**Ensure you have the following files**:

- `cnn_model.h5`: The saved CNN model.
- `rnn_model.h5`: The saved RNN model.
- `X_test.npy`: The preprocessed test data features.
- `y_test.npy`: The test data labels.
- `tokenizer.pickle`: The tokenizer used for text preprocessing.

---

[load_and_preprocess_data.py](https://www.notion.so/load_and_preprocess_data-py-2456b018869647a29be2de999f5c1ac9?pvs=21)

[**t`rain_model.py`**](https://www.notion.so/train_model-py-34882eccf1ed429786f61b68f93943b8?pvs=21)

[**`evaluate_model.py`**](https://www.notion.so/evaluate_model-py-5bdf18178a83400597632b3f3145af7c?pvs=21)

he class that corresponds to `1` (or the higher probability in case of a probabilistic output) is typically malware, while `0` (or the lower probability) is benign. Make sure your preprocessing, training, and evaluation scripts are consistently using this mapping.
